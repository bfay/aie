// SASSY MODULAR-SCALE
// https://github.com/scottkellum/modular-scale

// Defaults
$ms-ratio: golden_ratio() !default;
$ms-base: 16px !default;
$round-pixels: true !default;

// Modular Scale function
@function modular-scale($multiple, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  
  // return the $ms-base if $multiple is zero
  @if $multiple == 0 {
    @if type-of($ms-base) == "list" {
      $ms-base: sort_list($ms-base);
      @return nth($ms-base, 1);
    }
    
    // return just the simple $ms-base value if it's not a list
    @return $ms-base;
  }
  
  // if multiple base-sizes are passed in as a list
  // and multiple ratios are passed in as a list
  // calculate values in using each base-size / ratio combination
  @if type-of($ms-base) == "list" and type-of($ms-ratio) == "list" {
    @if unit(ms-multibase-multiratio($multiple, $ms-base, $ms-ratio)) == "px" and $round-pixels == true {
      @return round(ms-multibase-multiratio($multiple, $ms-base, $ms-ratio));
    }
    @return ms-multibase-multiratio($multiple, $ms-base, $ms-ratio);
  }
  
  // if multiple base-sizes are passed in as a list
  // calculate values in using each base-size
  @if type-of($ms-base) == "list" and type-of($ms-ratio) == "number" {
    @if unit(ms-multibase($multiple, $ms-base, $ms-ratio)) == "px" and $round-pixels == true {
      @return round(ms-multibase($multiple, $ms-base, $ms-ratio));
    }
    @return ms-multibase($multiple, $ms-base, $ms-ratio);
  }
  
  // if multiple ratios are passed in as a list
  // calculate values in using each ratio
  @if type-of($ms-base) == "number" and type-of($ms-ratio) == "list" {
    @if unit(ms-multiratio($multiple, $ms-base, $ms-ratio)) == "px" and $round-pixels == true {
      @return round(ms-multiratio($multiple, $ms-base, $ms-ratio));
    }
    @return ms-multiratio($multiple, $ms-base, $ms-ratio);
  }
  
  // If there are no lists just run the simple function
  @if unit(power($ms-ratio, $multiple) * $ms-base) == "px" and $round-pixels == true {
    @return round(power($ms-ratio, $multiple) * $ms-base);
  }
  @return power($ms-ratio, $multiple) * $ms-base;
}

// calculate values in using each base-size / ratio combination
@function ms-multibase-multiratio($multiple, $ms-base: $ms-base, $ms-ratio: $ms-ratio) {
  
  // start with an empty list to place all values in
  $scale-values: ();
  
  // make sure base sizes are in ascending order
  $ms-base: sort_list($ms-base);
  
  // take each base-size in turn
  $k: 1;
  @while $k <= length($ms-base) {
    
    // add each $ms-base to the list except the first
    @if $k > 1 {
      $scale-values: append($scale-values, nth($ms-base, $k));
    }
    
    // take each ratio in turn
    $j: 1;
    @while $j <= length($ms-ratio) {
      
      // reset $modular-scale for each set
      $modular-scale: nth($ms-base, $k);
      
      // do the scale for each base-size using this ratio
      @if $multiple > 0 {
        
        // up $multiple times
        // and add the result to $scale-values
        @for $i from 1 through $multiple {
          $modular-scale: power(nth($ms-ratio, $j), $i) * nth($ms-base, $k);
          $scale-values: append($scale-values, $modular-scale);
        }
        
        // and down until the value is lower than the lowest $ms-base
        // and add the result to $scale-values
        $i: -1;
        $modular-scale: nth($ms-base, $k);
        @while $modular-scale >= nth($ms-base, 1) {
          $modular-scale: power(nth($ms-ratio, $j), $i) * nth($ms-base, $k);
          $scale-values: append($scale-values, $modular-scale);
          $i: $i - 1;
        }
      }
      @if $multiple < 0 {
        
        // do the scale down for each set to below 1px
        $i: 0;
        $modular-scale: nth($ms-base, $k);
        @while $i >= $multiple {
          $modular-scale: power(nth($ms-ratio, $j), $i) * nth($ms-base, $k);
          $scale-values: append($scale-values, $modular-scale);
          $i: $i - 1;
        }
      }
      $j: $j + 1;
    }
    $k: $k + 1;
  }
  
  // return trimmed and sorted final list
  @return trim-sort($multiple, $scale-values, $ms-base);
}

// calculate values in using each base-size
@function ms-multibase($multiple, $ms-base: $ms-base, $ms-ratio: $ms-ratio) {
  
  // start with an empty list to place all values in
  $scale-values: ();
  
  // make sure base sizes are in ascending order
  $ms-base: sort_list($ms-base);
  
  // take each base-size in turn
  $k: 1;
  @while $k <= length($ms-base) {
    
    // add each $ms-base to the list except the first
    @if $k > 1 {
      $scale-values: append($scale-values, nth($ms-base, $k));
    }
    
    // reset $modular-scale for each set
    $modular-scale: nth($ms-base, $k);
    
    // do the scale for each base-size using this ratio
    @if $multiple > 0 {
      
      // up $multiple times
      // and add the result to $scale-values
      @for $i from 1 through $multiple {
        $modular-scale: power($ms-ratio, $i) * nth($ms-base, $k);
        $scale-values: append($scale-values, $modular-scale);
      }
      
      // and down until the value is lower than the lowest $ms-base
      // and add the result to $scale-values
      $i: -1;
      $modular-scale: nth($ms-base, $k);
      @while $modular-scale >= nth($ms-base, 1) {
        $modular-scale: power($ms-ratio, $i) * nth($ms-base, $k);
        $scale-values: append($scale-values, $modular-scale);
        $i: $i - 1;
      }
    }
    @if $multiple < 0 {
      
      // do the scale down for each set to below 1px
      $i: 0;
      $modular-scale: nth($ms-base, $k);
      @while $i >= $multiple {
        $modular-scale: power($ms-ratio, $i) * nth($ms-base, $k);
        $scale-values: append($scale-values, $modular-scale);
        $i: $i - 1;
      }
    }
    $k: $k + 1;
  }
  
  // return trimmed and sorted final list
  @return trim-sort($multiple, $scale-values, $ms-base);
}

// calculate values in using each ratio
@function ms-multiratio($multiple, $ms-base: $ms-base, $ms-ratio: $ms-ratio) {
  
  // start with an empty list to place all values in
  $scale-values: ();
  
  // If $multiple is a positive integer (up the scale)
  @if $multiple > 0 {
    
    // take each ratio in turn
    $j: 1;
    @while $j <= length($ms-ratio) {
      
      // reset $modular-scale for each set
      $modular-scale: $ms-base;
      
      // do the scale using this ratio thru the multiple, and add the result to $scale-values
      @for $i from 1 through $multiple {
        $modular-scale: power(nth($ms-ratio, $j), $i) * $ms-base;
        $scale-values: append($scale-values, $modular-scale);
      }
      $j: $j + 1;
    }
    
    // sort acsending
    $scale-values: sort_list($scale-values);
    
    // return the final value using the laced list
    @return nth($scale-values, $multiple);
  }
  
  // If $multiple is a negative integer (down the scale)
  @if $multiple < 0 {
    
    // take each ratio in turn
    $j: 1;
    @while $j <= length($ms-ratio) {
      
      // reset $modular-scale for each set
      $modular-scale: $ms-base;
      
      // do the scale using this ratio thru the multiple, and add the result to $scale-values
      @for $i from 1 through $multiple * -1 {
        $modular-scale: power(nth($ms-ratio, $j), -$i) * $ms-base;
        $scale-values: append($scale-values, $modular-scale);
      }
      $j: $j + 1;
    }
    
    // sort decending
    $scale-values: reverse_list(sort_list($scale-values));
    
    // return the final value using the laced list
    @return nth($scale-values, $multiple * -1);
  }
}

// trim and sort the final list
@function trim-sort($multiple, $scale-values: $scale-values, $ms-base: $ms-base) {
  @if $multiple > 0 {
    
    // trim list so we can count from the lowest $ms-base
    $scale-values: trim_list($scale-values, nth($ms-base, 1), true);
    
    // sort acsending
    $scale-values: sort_list($scale-values);
    
    // return the final value using the laced list
    @return nth($scale-values, $multiple);
  }
  @else {
    
    // trim list so we can count from the lowest $ms-base
    $scale-values: trim_list($scale-values, nth($ms-base, 1), false);
    
    // sort acsending
    $scale-values: reverse_list(sort_list($scale-values));
    
    // return the final value using the laced list
    @return nth($scale-values, -$multiple);
  }
}

/////////////////////////////////////////////////////////////////////////

// alias for golden_ratio()
@function golden() {
  @return golden_ratio();
}

// Shortcut
@function ms($multiple, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  // Return the value from the Modular Scale function
  @return modular-scale($multiple, $ms-base, $ms-ratio, $round-pixels);
}

// Write Modular Scale List
@function modular-scale-list($start: 0, $finish: 20, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  $ms-list: unquote("MS-LIST:");
  @for $i from $start through $finish {
    $ms-list: append($ms-list, ms($i, $ms-base, $ms-ratio, $round-pixels));
  }
  @return $ms-list;
}

@function ms-list($start: 0, $finish: 20, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  @return modular-scale-list($start, $finish, $ms-base, $ms-ratio, $round-pixels);
}

@mixin modular-scale-list($start: 0, $finish: 20, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  @debug modular-scale-list($start, $finish, $ms-base, $ms-ratio, $round-pixels);
}

@mixin ms-list($start: 0, $finish: 20, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  @debug modular-scale-list($start, $finish, $ms-base, $ms-ratio, $round-pixels);
}

@mixin modular-scale-list-output($start: 0, $finish: 20, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
    MODULAR-SCALE-LIST {
      ms-list: modular-scale-list($start, $finish, $ms-base, $ms-ratio, $round-pixels);
    }
  }

@mixin ms-list-output($start: 0, $finish: 20, $ms-base: $ms-base, $ms-ratio: $ms-ratio, $round-pixels: $round-pixels) {
  @include modular-scale-list-output($start, $finish, $ms-base, $ms-ratio, $round-pixels);
}

// Other libraries can easily query if this function is avalible
$modular-scale-loaded: true;